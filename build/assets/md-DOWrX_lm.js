import{b as r,o as i,w as s,g as l,ad as e,v as a,x as c,T as o}from"./modules/vue-C3wmdS3C.js";import{I as d}from"./slidev/default-DWjjwV1l.js";import{u as _,f as m}from"./slidev/context-Cv_S9V0q.js";import"./index-BsII1Axt.js";import"./modules/shiki-D3-9XqGl.js";const w={__name:"slides.md__slidev_6",setup(p){const{$clicksContext:t,$frontmatter:u}=_();return t.setup(),(f,n)=>(i(),r(d,a(c(o(m)(o(u),5))),{default:s(()=>n[0]||(n[0]=[l("h1",null,"整体算法流程 (3/4) - 法线估计与一致性检查",-1),l("div",{class:"text-left"},[l("ol",{start:"2"},[l("li",null,[l("strong",null,[e("逐参考帧 (Frame "),l("code",null,"i"),e(") 处理 - 点的评估")]),e(": "),l("ul",null,[l("li",null,[l("strong",null,"鲁棒法线估计"),e(": "),l("ul",null,[l("li",null,[e("为 "),l("code",null,"pointCam"),e(" 计算在相机坐标系下的法线 "),l("code",null,"normal_cam"),e("。优先使用中心差分，若邻域深度不连续则回退到单边差分或视线方向。")]),l("li",null,[e("确保法线指向相机方向，然后将其转换到世界坐标系得到 "),l("code",null,"normal_world"),e("。")])])]),l("li",null,[l("strong",null,"多视图深度一致性检查"),e(": "),l("ul",null,[l("li",null,[e("选取参考帧 "),l("code",null,"i"),e(" 的一组时序上邻近的帧 "),l("code",null,"j"),e("。")]),l("li",null,[e("将 "),l("code",null,"pointWorld_candidate"),e(" 投影回每个邻居帧 "),l("code",null,"j"),e(" 的图像平面，得到投影深度 "),l("code",null,"projected_depth_in_neighbor_cam"),e("。")]),l("li",null,[e("比较此投影深度与邻居帧 "),l("code",null,"j"),e(" 在对应投影像素处实际存储的深度 "),l("code",null,"actual_depth_in_neighbor_image"),e("。")]),l("li",null,[e("若两者的相对差异小于 "),l("code",null,"DEPTH_CONSISTENCY_THRESHOLD_RELATIVE"),e("，则认为此邻居帧 "),l("code",null,"j"),e(" 支持该点，"),l("code",null,"consistent_views_count"),e(" 加一。")]),l("li",null,[e("若 "),l("code",null,"consistent_views_count"),e(" 达到之前计算的 "),l("code",null,"required_views_count"),e("，则该点通过深度一致性检查。")])])])])])])],-1)])),_:1,__:[0]},16))}};export{w as default};
